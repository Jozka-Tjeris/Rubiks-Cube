/* autogenerated by Processing revision 1293 on 2024-07-05 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Collections;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Rubiks_Cube extends PApplet {





boolean rotateX = false;
boolean rotateY = false;
boolean rotateZ = false;
boolean isClockwise = true;
boolean upKeyPressed = false;
boolean downKeyPressed = false;
boolean leftKeyPressed = false;
boolean rightKeyPressed = false;
boolean lessThanKeyPressed = false;
boolean moreThanKeyPressed = false;
boolean spacebarPressed = false;
boolean mouseHeldDown = false;
PFont f;

Cube cube;
int size = 10;
int currentDepth = 0;
PVector rotation = new PVector(0, 0, 0);
PVector center = new PVector(400, 400, 0);
int[] blockLengths = {106, 204/2, 222/3, 240/4, 240/5, 240/6, 280/7, 320/8, 324/9, 400/10};
float[] marginOfErrors = {0, 0, 0.1f, 0.1f, 0.1f, 0.1f, 0.3f, 0.3f, 0.3f, 0.3f};

//f = (s - n)/2
float[] cameraDistanceFactors = {9, 16, 19, 20, 25, 30, 35, 48, 55, 60};
float[] scalingFactors =        {4, 7 , 8 , 8 , 10, 12, 14, 20, 23, 25};

float[] cosTable = new float[720];
float[] sinTable = new float[720];

PVector prevPos = new PVector(400, 400, 0);
PVector currPos = new PVector(400, 400, 0);
float scaleFactor = 0.9f;

int movingCounter = 0;
boolean fillBlocks = false;
boolean doubleTurn = false;

final int RFace = color(240, 0, 0);
final int LFace = color(240, 120, 0);
final int FFace = color(0, 240, 0);
final int BFace = color(0, 0, 240);
final int UFace = color(250);
final int DFace = color(240, 240, 0);
final int blockFill = color(30);
final int blockStroke = color(50);

public void setup(){
  /* size commented out by preprocessor */;
  f = createFont("TimesNewRomanPSMT", 20);
  textFont(f);
  
  for(int i = 0; i < 720; i++){
    cosTable[i] = cos((float)Math.toRadians(i * 0.5f));
    sinTable[i] = sin((float)Math.toRadians(i * 0.5f));
  }
  
  //clamp size number
  if(size < 1) size = 1;
  if(size > 10) size = 10;
    
  //create new cube
  cube = new Cube(size, blockLengths[size - 1], fillBlocks);
}

public void draw(){
  background(220);
  
  cube.show();
  updateCubeRotationState();
  showMetrics();
  cube.updateMoves();
  
  if(mouseHeldDown){
    strokeWeight(8);
    stroke(0);
    point(mouseX, mouseY);
  }
  findAxis(mouseHeldDown);
}

public void keyPressed(){
  if(key == 'i') isClockwise = !isClockwise;
  if(keyCode == SHIFT) isClockwise = false;
  
  if(keyCode == '\t') doubleTurn = true;
  
  if(key == ' '){
    spacebarPressed = !spacebarPressed;
    rotateX = false;
    rotateY = false;
    rotateZ = false;
  }else{
    if(key == 'x') rotateX = !rotateX;
    if(key == 'y') rotateY = !rotateY;
    if(key == 'z') rotateZ = !rotateZ;
  }
  
  if(keyCode == UP) upKeyPressed = true;
  if(keyCode == DOWN) downKeyPressed = true;
  if(keyCode == RIGHT) rightKeyPressed = true;
  if(keyCode == LEFT) leftKeyPressed = true;
  if(key == ',') lessThanKeyPressed = true;
  if(key == '.') moreThanKeyPressed = true;
  
  if(key == '\n'){
    spacebarPressed = false;
    rotateX = false;
    rotateY = false;
    rotateZ = false;
    cube.reset();
  }

  if(key == 'u' || key == 'U') cube.addMove(Moves.U, currentDepth, isClockwise, (doubleTurn ? 2 : 1));
  if(key == 'd' || key == 'D') cube.addMove(Moves.D, currentDepth, isClockwise, (doubleTurn ? 2 : 1));
  if(key == 'f' || key == 'F') cube.addMove(Moves.F, currentDepth, isClockwise, (doubleTurn ? 2 : 1));
  if(key == 'b' || key == 'B') cube.addMove(Moves.B, currentDepth, isClockwise, (doubleTurn ? 2 : 1));
  if(key == 'l' || key == 'L') cube.addMove(Moves.L, currentDepth, isClockwise, (doubleTurn ? 2 : 1));
  if(key == 'r' || key == 'R') cube.addMove(Moves.R, currentDepth, isClockwise, (doubleTurn ? 2 : 1));
  
  if(keyCode == BACKSPACE && cube.turnQueue.size() > 0) cube.turnQueue.removeLast();
  
  if('1' <= key && key <= '9') setDepth(key - '0');
}

public void keyReleased(){
  if(keyCode == SHIFT) isClockwise = true;
  if(keyCode == '\t') doubleTurn = false;
  if(keyCode == UP) upKeyPressed = false;
  if(keyCode == DOWN) downKeyPressed = false;
  if(keyCode == RIGHT) rightKeyPressed = false;
  if(keyCode == LEFT) leftKeyPressed = false;
  if(key == ',') lessThanKeyPressed = false;
  if(key == '.') moreThanKeyPressed = false;
}

public void showMetrics(){
  textFont(f);
  fill(0);
  text("x: " + cube.blocks[0].rotation.x + (char)0x00B0, 10, 30);
  text("y: " + cube.blocks[0].rotation.y + (char)0x00B0, 10, 60);
  text("z: " + cube.blocks[0].rotation.z + (char)0x00B0, 10, 90);
  
  String direction = (isClockwise) ? "Clockwise" : "Counter-Clockwise";
  text("Direction: " + direction, 10, 120);
  text("Current Layer: " + (currentDepth + 1), 10, 150);
  text("Turn mode: " + (doubleTurn ? "Double" : "Single"), 10, 180);
  
  text("Moves List:", 10, 210);
  String s = (cube.currentTurn != null) ? cube.currentTurn.getInformation() + " " : "";
  for(Turn t: cube.turnQueue) s += t.getInformation() + " ";
  text(s, 10, 240);
}

public void updateCubeRotationState(){  
  int amount = 1;
  if(isClockwise) amount = -1;
  int rotationSpeed = 2;
  
  if(upKeyPressed) cube.updateState('x', 1*rotationSpeed);
  if(downKeyPressed) cube.updateState('x', -1*rotationSpeed);
  if(rightKeyPressed) cube.updateState('y', 1*rotationSpeed);
  if(leftKeyPressed) cube.updateState('y', -1*rotationSpeed);
  if(lessThanKeyPressed) cube.updateState('z', -1*rotationSpeed);
  if(moreThanKeyPressed) cube.updateState('z', 1*rotationSpeed);
  
  if(spacebarPressed){
    cube.updateState('x', amount*rotationSpeed);
    cube.updateState('y', amount*rotationSpeed);
    cube.updateState('z', amount*rotationSpeed);
  }else{
    if(rotateX) cube.updateState('x', amount*rotationSpeed);
    if(rotateY) cube.updateState('y', amount*rotationSpeed);
    if(rotateZ) cube.updateState('z', amount*rotationSpeed);
  }
}

public void mousePressed(){
  mouseHeldDown = true;
}

public void mouseReleased(){
  mouseHeldDown = false;
}

public void findAxis(boolean hasNewPos){
  currPos.x = mouseX;
  currPos.y = mouseY;
  
  if(!hasNewPos){
    prevPos.x = mouseX;
    prevPos.y = mouseY;
  }

  int xDisp = (int)(currPos.x - prevPos.x)/2;
  int yDisp = (int)(currPos.y - prevPos.y)/2;
  
  cube.updateState('x', -yDisp);
  cube.updateState('y', xDisp);
  
  prevPos.x = currPos.x;
  prevPos.y = currPos.y;
}

//This project uses the CubeRotation Sketch as the foundation
//Main video used as source: https://www.youtube.com/watch?v=p4Iz0XJY-Qk
//CubeRotation notes:
//27 May: Added graphics for points
//28 May: Added lines to make box, added rotations, added directional axes, added the ability to offset the block
//
//Rubiks_Cube notes: 
//28 May: Added displacement generator
//29 May: Added Cube class to consolidate the blocks and axis, created a 3D space of cubes
//30 May: Corrected the display of the cube (selective face-rendering), removing unneccessary shapes
//31 May: Added coloured tiles
//1 Jun: Started to add weak perspective projection
//2 Jun: Added weak perspective projection
//3 Jun: Applied colored tiles using new weak perspective projection method
//7 Jun: Learning how proper 3D rotations work (main source: https://www.youtube.com/watch?v=aMqeG_0aFd0)
//9 Jun: Added proper 3D rotations
//14 & 15 Jun: Overhauled the cube display algorithm to facilitate turns
//16 Jun: Added surface-level turns (without reference switching)
//17 Jun: Added Turn class (Cleaned up code)
//18 Jun: Added reference switching (allowing turns on multiple faces)
//19 Jun: Refactored some code (reference switching)
//20-21 Jun: Added slices (turns on inner layers)
//22 Jun: Fixed the reset button, removed old code (matrix transformation-based rotations)
//26-27 Jun: Improved the rendering process when doing slice turns
//28-29 Jun: Tweaked the rendering process to reduce computations and increase reliability
//1-2 Jul: Fixed the rendering process to handle surface and slice turns, added option to change depth and direction of turns
//2 Jul: Fixed the turn input system, added list to store multiple moves at once, added a way to delete turns, 
//2 Jul: added hotfix for rendering odd-layered cubes (incorrect indexing) and layer switching
//3 Jul: Started adding solid block colors to the cube, attempting to fix turn rendering to accomodate the new feature
//4 Jul: Fixed the face-rendering system to accomodate for extra faces (solid-blocks setting only), added double turns
class Axis{
  PVector[] originalPointDisps = new PVector[6];
  PVector[] pointDisps = new PVector[6];
  PVector[] originalPoints = new PVector[6];
  PVector[] points = new PVector[6];
  PVector center = new PVector(0, 0, 0);
  float axisLength = 0;
  
  public Axis(PVector v, float l){
    center = v.copy();
    axisLength = l;
    
    pointDisps[0] = new PVector(-1, 0, 0);
    pointDisps[1] = new PVector(1, 0, 0);
    pointDisps[2] = new PVector(0, -1, 0);
    pointDisps[3] = new PVector(0, 1, 0);
    pointDisps[4] = new PVector(0, 0, -1);
    pointDisps[5] = new PVector(0, 0, 1);
    
    originalPointDisps = pointDisps.clone();
    
    for(int i = 0; i < pointDisps.length; i++){
      //add distance to points based on the point disps, scaled by half its length
      points[i] = center.copy().add(pointDisps[i].copy().mult(l/2));
    }
    
    originalPoints = points.clone();
  }
  
  public void show(){
    stroke(170);
    strokeWeight(16);    
    for(int i = 0; i < 3; i++){
      point(points[2*i + 1].x, points[2*i + 1].y);

      char text = ' ';
      if(i == 0) text = 'x';
      if(i == 1) text = 'y';
      if(i == 2) text = 'z';  
      fill(0);
      text(text, points[2*i + 1].x, points[2*i + 1].y);
    }
    
    strokeWeight(2);    
    for(int i = 0; i < 3; i++){
      stroke(120*i, 120 + 60*i, 200 - (50*i));
      line(points[2*i].x, points[2*i].y, points[2*i + 1].x, points[2*i + 1].y);
    }
  }
  
  public void reset(){
    rotation = new PVector(0, 0, 0);
    pointDisps = originalPointDisps.clone();
    points = originalPoints.clone();
  }
  
  public void transform(char direction, float amount){
    if(direction == 'x') rotation.x += amount;
    if(direction == 'y') rotation.y += amount;
    if(direction == 'z') rotation.z += amount;
    
    while(rotation.x < 0) rotation.x += 360;
    while(rotation.y < 0) rotation.y += 360;
    while(rotation.z < 0) rotation.z += 360;
  }
  
  public void updateQXYZ(char direction, int amount){
    for(int i = 0; i < pointDisps.length; i++){
      pointDisps[i] = rotateAroundAxis(amount, direction, pointDisps[i]);
      points[i] = center.copy().add(pointDisps[i].copy().mult(axisLength/2));
    }
  }
  
  public void updateQAroundAxis(PVector axisOfRotation, int amount){
    for(int i = 0; i < pointDisps.length; i++){
      pointDisps[i] = rotateAroundCustomAxis(amount, axisOfRotation, pointDisps[i]);
      points[i] = center.copy().add(pointDisps[i].copy().mult(axisLength/2));
    }
  }
  
  public PVector getAxisOfRotation(char direction, boolean flipped){
    switch(direction){
      case 'x':
        PVector xAxis = points[1].copy().sub(points[0].copy()).normalize();
        if(flipped) xAxis.mult(-1);
        return xAxis;
      case 'y':
        PVector yAxis = points[3].copy().sub(points[2].copy()).normalize();
        if(flipped) yAxis.mult(-1);
        return yAxis;
      case 'z':
        PVector zAxis = points[5].copy().sub(points[4].copy()).normalize();
        if(flipped) zAxis.mult(-1);
        return zAxis;
    }
    return new PVector(0, 0, 0);
  }
}
class Block{
  PVector[] originalPointDisps = new PVector[8]; //TLB, TRB, BLB, BRB, TLF, TRF, BLF, BRF
  PVector[] pointDisps = new PVector[8]; //Points before perspective projection
  PVector[] perspectivePoints = new PVector[8]; //Points after perspective projection
  PVector[] originalInteriorPoints = new PVector[8*3]; //Stores points for colored faces (default position)
  PVector[] interiorPoints = new PVector[8*3]; //Interior points before perspective projection
  PVector[] projectedInteriorPoints = new PVector[8*3]; //Interior points after perspective projection
  //Each point has 3 different interior points: xy, xz, yz
  /*
    Index to letter key:
    1  = White; A  2  = Orange; E  12 = Green; I  17 = Red; M  3  = Blue; Q  19 = Yellow; U
    4  = White; B  14 = Orange; F  15 = Green; J  5  = Red: N  0  = Blue; R  22 = Yellow; V
    16 = White; C  20 = Orange; G  18 = Green; L  11 = Red; O  6  = Blue; S  10 = Yellow; W
    13 = White; D  8  = Orange; H  21 = Green; K  23 = Red; P  9  = Blue; T  7  = Yellow; X
  */
  PVector center = new PVector(0, 0, 0);
  PVector currCenter = new PVector(0, 0, 0);
  float sideLength = 0;
  PVector distToCenter = new PVector(0, 0, 0); //stores it as a multiple of sideLength, not absolute distance
  PVector rotation = new PVector(0, 0, 0);
  int[] sideColors = {-1, -1, -1, -1, -1, -1}; //U, D, R, L, F, B
                    //-1 = draw nothing, 0 = black square, 1 = black square with color inside
  String[] relativePositions = {"U", "D", "R", "L", "F", "B"}; //stores the faces displayed with rotations applied
  ArrayList<String> neighbors = new ArrayList<String>();
  ArrayList<String> facesToShow = new ArrayList<String>();
  boolean isMoving = false;
  boolean fillBlock = false;
      
  Block(PVector v, float l, PVector distanceToCenter, boolean filled){
    setDistanceFactorFromCenter(distanceToCenter);
    center = v.copy();
    sideLength = l;
    fillBlock = filled;
    
    for(int i = 0; i < pointDisps.length; i++){
      originalPointDisps[i] = new PVector(2*(i & 1) - 1, 
                                          2*((i & 2) >> 1) - 1, 
                                          2*((i & 4) >> 2) - 1);
      pointDisps[i] = originalPointDisps[i].copy();
    }
    
    neighbors.addAll(Arrays.asList("F", "B", "U", "D", "L", "R"));
    
    perspectivePoints = applyPerspectiveProjection(pointDisps, distToCenter);
    for(int i = 0; i < pointDisps.length; i++){
      PVector XYColors = new PVector(pointDisps[i].x * scaleFactor, pointDisps[i].y * scaleFactor, pointDisps[i].z);
      PVector XZColors = new PVector(pointDisps[i].x * scaleFactor, pointDisps[i].y, pointDisps[i].z * scaleFactor);
      PVector YZColors = new PVector(pointDisps[i].x, pointDisps[i].y * scaleFactor, pointDisps[i].z * scaleFactor);
            
      originalInteriorPoints[i*3] = XYColors;
      interiorPoints[i*3] = XYColors.copy();

      originalInteriorPoints[i*3 + 1] = XZColors;
      interiorPoints[i*3 + 1] = XZColors.copy();

      originalInteriorPoints[i*3 + 2] = YZColors;
      interiorPoints[i*3 + 2] = YZColors.copy();
    }
    
    projectedInteriorPoints = applyPerspectiveProjection(interiorPoints, distToCenter);
  }
  
  public void removeNeighbor(String direction){
    if(!Moves.getAllFaces().contains(direction)) return;
    neighbors.remove(direction);
    facesToShow.add(direction);
    sideColors[Moves.valueOf(direction).ordinal()] = 1;
  }
  
  public void setDistanceFactorFromCenter(PVector v){
    distToCenter = v.copy();
  }
  
  public void showFace(Moves move){
    strokeWeight(1);
    stroke(blockStroke);
    fill(blockFill);
    if(!fillBlock) noFill();
    if(sideColors[5] >= 0 && move == Moves.B){
      //4576, Z- face (B)
      quad(perspectivePoints[0].x, perspectivePoints[0].y, 
           perspectivePoints[1].x, perspectivePoints[1].y, 
           perspectivePoints[3].x, perspectivePoints[3].y, 
           perspectivePoints[2].x, perspectivePoints[2].y);
    }
    if(sideColors[4] >= 0 && move == Moves.F){
      //0132, Z+ face (F)
      quad(perspectivePoints[4].x, perspectivePoints[4].y, 
           perspectivePoints[5].x, perspectivePoints[5].y, 
           perspectivePoints[7].x, perspectivePoints[7].y, 
           perspectivePoints[6].x, perspectivePoints[6].y);
    }
    if(sideColors[0] >= 0 && move == Moves.U){
      //0154, Y- Face (U)
      quad(perspectivePoints[0].x, perspectivePoints[0].y,
           perspectivePoints[1].x, perspectivePoints[1].y, 
           perspectivePoints[5].x, perspectivePoints[5].y, 
           perspectivePoints[4].x, perspectivePoints[4].y);
    }
    if(sideColors[1] >= 0 && move == Moves.D){
      //2376, Y+ Face (D)
      quad(perspectivePoints[2].x, perspectivePoints[2].y, 
           perspectivePoints[3].x, perspectivePoints[3].y, 
           perspectivePoints[7].x, perspectivePoints[7].y, 
           perspectivePoints[6].x, perspectivePoints[6].y);
    }
    if(sideColors[3] >= 0 && move == Moves.L){
      //0264, X- Face (L)
      quad(perspectivePoints[0].x, perspectivePoints[0].y, 
           perspectivePoints[2].x, perspectivePoints[2].y, 
           perspectivePoints[6].x, perspectivePoints[6].y, 
           perspectivePoints[4].x, perspectivePoints[4].y);
    }
    if(sideColors[2] >= 0 && move == Moves.R){
      //1375, X+ Face (R)
      quad(perspectivePoints[1].x, perspectivePoints[1].y, 
           perspectivePoints[3].x, perspectivePoints[3].y, 
           perspectivePoints[7].x, perspectivePoints[7].y, 
           perspectivePoints[5].x, perspectivePoints[5].y);
    }
  }
  
  public void showColor(Moves move){
    noStroke();
    if(sideColors[5] >= 1 && move == Moves.B){
      //3.0.6.9, Z- Face (B)
      fill(BFace);
      quad(projectedInteriorPoints[3].x, projectedInteriorPoints[3].y, 
           projectedInteriorPoints[0].x, projectedInteriorPoints[0].y,
           projectedInteriorPoints[6].x, projectedInteriorPoints[6].y,
           projectedInteriorPoints[9].x, projectedInteriorPoints[9].y);
    }
    if(sideColors[4] >= 1 && move == Moves.F){
      //12.15.21.18, Z+ Face (F)
      fill(FFace);
      quad(projectedInteriorPoints[12].x, projectedInteriorPoints[12].y, 
           projectedInteriorPoints[15].x, projectedInteriorPoints[15].y,
           projectedInteriorPoints[21].x, projectedInteriorPoints[21].y,
           projectedInteriorPoints[18].x, projectedInteriorPoints[18].y);
    }
    if(sideColors[0] >= 1 && move == Moves.U){
      //1.4.16.13, Y- Face (U)
      fill(UFace);
      quad(projectedInteriorPoints[1].x, projectedInteriorPoints[1].y, 
           projectedInteriorPoints[4].x, projectedInteriorPoints[4].y,
           projectedInteriorPoints[16].x, projectedInteriorPoints[16].y,
           projectedInteriorPoints[13].x, projectedInteriorPoints[13].y);
    }
    if(sideColors[1] >= 1 && move == Moves.D){
      //19.22.10.7, Y+ Face (D)
      fill(DFace);
      quad(projectedInteriorPoints[19].x, projectedInteriorPoints[19].y, 
           projectedInteriorPoints[22].x, projectedInteriorPoints[22].y,
           projectedInteriorPoints[10].x, projectedInteriorPoints[10].y,
           projectedInteriorPoints[7].x, projectedInteriorPoints[7].y);
    }
    if(sideColors[3] >= 1 && move == Moves.L){
      //2.14.20.8, X- Face (L)
      fill(LFace);
      quad(projectedInteriorPoints[2].x, projectedInteriorPoints[2].y, 
           projectedInteriorPoints[14].x, projectedInteriorPoints[14].y,
           projectedInteriorPoints[20].x, projectedInteriorPoints[20].y,
           projectedInteriorPoints[8].x, projectedInteriorPoints[8].y);
    }
    if(sideColors[2] >= 1 && move == Moves.R){
      //17.5.11.23, X+ Face (R)
      fill(RFace);
      quad(projectedInteriorPoints[17].x, projectedInteriorPoints[17].y, 
           projectedInteriorPoints[5].x, projectedInteriorPoints[5].y,
           projectedInteriorPoints[11].x, projectedInteriorPoints[11].y,
           projectedInteriorPoints[23].x, projectedInteriorPoints[23].y);
    }
  }
  
  /*
    U clockwise and D anti-clockwise: (0 1 2 3 4 5 --> 0 1 5 4 2 3)
    U D R L F B --> U D B F R L --> U D L R B F --> U D F B L R --> U D R L F B
    
    U anti-clockwise and D clockwise: (0 1 2 3 4 5 --> 0 1 4 5 3 2)
    U D R L F B --> U D F B L R --> U D L R B F --> U D B F R L --> U D R L F B
    
    R clockwise and L anti-clockwise: (0 1 2 3 4 5 --> 4 5 2 3 1 0)
    U D R L F B --> F B R L D U --> D U R L B F --> B F R L U D --> U D R L F B
    
    R anti-clockwise and L clockwise: (0 1 2 3 4 5 --> 5 4 2 3 0 1)
    U D R L F B --> B F R L U D --> D U R L B F --> F B R L D U --> U D R L F B
    
    F clockwise and B anti-clockwise: (0 1 2 3 4 5 --> 3 2 0 1 4 5)
    U D R L F B --> L R U D F B --> D U L R F B --> R L D U F B --> U D R L F B
    
    F anti-clockwise and B clockwise: (0 1 2 3 4 5 --> 2 3 1 0 4 5)
    U D R L F B --> R L D U F B --> D U L R F B --> L R U D F B --> U D R L F B
  */
  
  public int[] getTurnModifierArray(Moves m, boolean isClockwise){
    int[] res = {0, 1, 2, 3, 4, 5};
    if((m == Moves.U && isClockwise == true) || (m == Moves.D && isClockwise == false)){
      res = new int[] {0, 1, 5, 4, 2, 3};
    }
    if((m == Moves.U && isClockwise == false) || (m == Moves.D && isClockwise == true)){
      res = new int[] {0, 1, 4, 5, 3, 2};
    }
    if((m == Moves.R && isClockwise == true) || (m == Moves.L && isClockwise == false)){
      res = new int[] {4, 5, 2, 3, 1, 0};
    }
    if((m == Moves.R && isClockwise == false) || (m == Moves.L && isClockwise == true)){
      res = new int[] {5, 4, 2, 3, 0, 1};
    }
    if((m == Moves.F && isClockwise == true) || (m == Moves.B && isClockwise == false)){
      res = new int[] {3, 2, 0, 1, 4, 5};
    }
    if((m == Moves.F && isClockwise == false) || (m == Moves.B && isClockwise == true)){
      res = new int[] {2, 3, 1, 0, 4, 5};
    }
    return res;
  }
  
  public void applyTurnRotation(Turn t){
    for(int counter = 0; counter < t.turnCount; counter++){
      int[] modifier = getTurnModifierArray(Moves.valueOf(t.faceToTurn), t.directionAmount > 0 ? true : false);
      String[] newFacesArr = new String[6];
      for(int i = 0; i < modifier.length; i++) newFacesArr[i] = relativePositions[modifier[i]];
      relativePositions = newFacesArr;
    }
  }
  
  public void setFaceState(Moves m, int state){
    if(facesToShow.contains(relativePositions[m.ordinal()]) || (state < -1 || state >= 1)) return;
    sideColors[Moves.valueOf(relativePositions[m.ordinal()]).ordinal()] = state;
  }
  
  public ArrayList<String> findFacesToShowNoFill(){
    HashMap<Moves, Float>zValues = new HashMap<Moves, Float>();
    for(String s: facesToShow) zValues.put(Moves.valueOf(s), getZDepth(s));
        
    ArrayList<String> resultFaces = new ArrayList<String>();
    int numOfFacesToConsider = zValues.size();
    for(int counter = 0; counter < numOfFacesToConsider; counter++){
      float currDepth = Integer.MAX_VALUE;
      String frontMostFace = "_";

      for(Moves currFace: zValues.keySet()){
        if(currDepth > zValues.get(currFace)){
          currDepth = zValues.get(currFace);
          frontMostFace = currFace.name();
        }
      }
      resultFaces.add(frontMostFace);
      zValues.remove(Moves.valueOf(frontMostFace));
    }
    return resultFaces;
  }
  
  /*
  Create a function that only allows 3 non-opposite faces to be shown at a given time:
  find the 3 front-most faces, compare that with the faces allowed to be drawn
  
  go through faces allowed to be drawn:
    if front-most faces contain faces allowed to be drawn, add to final list
    
  return final list
  */
  
  public ArrayList<String> findFacesToShow(){
    ArrayList<String> threeClosestFaces = new ArrayList<String>();
    ArrayList<String> allFaces = new ArrayList<String>();
    allFaces.addAll(Arrays.asList(Moves.getAllFaces().split("")));

    //finds the 3 frontmost faces
    for(int i = 0; i < 3; i++){
      float currClosestDepth = Integer.MIN_VALUE;
      String currClosestFace = "_";
      for(String s: allFaces){
        float currDepth = getZDepth(s);
        if(currDepth > currClosestDepth){
          currClosestDepth = currDepth;
          currClosestFace = s;
        }
      }
      threeClosestFaces.add(currClosestFace);
      allFaces.remove(currClosestFace);
    }
    
    HashMap<Moves, Float>zValues = new HashMap<Moves, Float>();
    for(int i = 0; i < sideColors.length; i++){
      if(sideColors[i] < 0) continue;
      zValues.put(Moves.values()[i], getZDepth(Moves.values()[i].name()));
    }
    //find the order of "enabled" faces to be drawn
    String[] frontMostFaces = new String[zValues.size()];
    for(int counter = 0; counter < frontMostFaces.length; counter++){
      float currDepth = Integer.MAX_VALUE;
      String frontMostFace = "_";

      for(Moves currFace: zValues.keySet()){
        if(currDepth > zValues.get(currFace)){
          currDepth = zValues.get(currFace);
          frontMostFace = currFace.name();
        }
      }
      frontMostFaces[counter] = frontMostFace;
      zValues.remove(Moves.valueOf(frontMostFace));
    }
    
    //find the intersection between the three frontmost faces and the "enabled" faces
    ArrayList<String> resultFaces = new ArrayList<String>();
    for(String s: frontMostFaces){
      if(threeClosestFaces.contains(s)) resultFaces.add(s);
    }
    
    return resultFaces;
  }
  
  public float getZDepth(String faceToFind){
    switch(faceToFind.charAt(0)){
      case 'U':
        return perspectivePoints[0].z + perspectivePoints[1].z + 
               perspectivePoints[5].z + perspectivePoints[4].z;
      case 'D':
        return perspectivePoints[2].z + perspectivePoints[3].z + 
               perspectivePoints[7].z + perspectivePoints[6].z;
      case 'R':
        return perspectivePoints[1].z + perspectivePoints[3].z + 
               perspectivePoints[7].z + perspectivePoints[5].z;
      case 'L':
        return perspectivePoints[0].z + perspectivePoints[2].z + 
               perspectivePoints[6].z + perspectivePoints[4].z;
      case 'F':
        return perspectivePoints[4].z + perspectivePoints[5].z + 
               perspectivePoints[7].z + perspectivePoints[6].z;
      case 'B':
        return perspectivePoints[0].z + perspectivePoints[1].z + 
               perspectivePoints[3].z + perspectivePoints[2].z;
    }
    return 0;
  }
  
  public void transform(char direction, int amount){
    if(direction == 'x') rotation.x = (rotation.x + amount) % 360;
    if(direction == 'y') rotation.y = (rotation.y + amount) % 360;
    if(direction == 'z') rotation.z = (rotation.z + amount) % 360;
    
    while(rotation.x < 0) rotation.x += 360;
    while(rotation.y < 0) rotation.y += 360;
    while(rotation.z < 0) rotation.z += 360;
  }
  
  public void updateQXYZ(char direction, int amt){
    distToCenter = rotateAroundAxis(amt, direction, distToCenter);
    for(int i = 0; i < pointDisps.length; i++) pointDisps[i] = rotateAroundAxis(amt, direction, pointDisps[i]);
    for(int i = 0; i < interiorPoints.length; i++) interiorPoints[i] = rotateAroundAxis(amt, direction, interiorPoints[i]);

    perspectivePoints = applyPerspectiveProjection(pointDisps, distToCenter);
    projectedInteriorPoints = applyPerspectiveProjection(interiorPoints, distToCenter);
  }
  
  public void updateQAroundAxis(PVector axis, int amt){
    distToCenter = rotateAroundCustomAxis(amt, axis, distToCenter);
    for(int i = 0; i < pointDisps.length; i++) pointDisps[i] = rotateAroundCustomAxis(amt, axis, pointDisps[i]);
    for(int i = 0; i < interiorPoints.length; i++) interiorPoints[i] = rotateAroundCustomAxis(amt, axis, interiorPoints[i]);

    perspectivePoints = applyPerspectiveProjection(pointDisps, distToCenter);
    projectedInteriorPoints = applyPerspectiveProjection(interiorPoints, distToCenter);
  }
  
  public PVector getCenter(){
    return currCenter.copy();
  }
}
class Cube{
  int cubeSize;
  Block[] blocks;
  Axis axis;
  HashMap<String, PieceGroup> blockGroups = new HashMap<String, PieceGroup>();
  ArrayList<String> displayOrder = new ArrayList<String>();
  ArrayList<HashMap<String, PieceGroup>> groupStages = new ArrayList<HashMap<String, PieceGroup>>();
  int moveAnimationCounter = 0;
  PVector[] originalBlockDisps;
  boolean readyToTurn = false;
  LinkedList<Turn> turnQueue = new LinkedList<Turn>();
  Turn currentTurn;
  boolean fillBlock;
  
  public Cube(int size, int blockLength, boolean drawFill){
    cubeSize = size;
    fillBlock = drawFill;
    axis = new Axis(center, size*blockLength + 80);
    blocks = new Block[size*size*size];
    originalBlockDisps = getNumbers(size);
    
    for(int i = 0; i < originalBlockDisps.length; i++){
      blocks[i] = new Block(center, blockLength, originalBlockDisps[i].copy(), fillBlock);
      removeNeighbors(blocks[i], originalBlockDisps[i], size);
      
      String facesToShow = getFacesToShow(blocks[i]);
      if(!blockGroups.containsKey(facesToShow)){
        String[] faceArray = new String[0];
        if(facesToShow != "") faceArray = facesToShow.split("");
        blockGroups.put(facesToShow, new PieceGroup(PieceType.getType(facesToShow), faceArray));
      }
      blockGroups.get(facesToShow).addBlockIdx(i);
    }
    
    for(String s: blockGroups.keySet()) blockGroups.get(s).setPosition(this);
    generateDisplayOrder(blockGroups);
  }
  
  private String getFacesToShow(Block b){
    String res = "";
    ArrayList<String> faces = new ArrayList<String>();
    faces.addAll(Arrays.asList("F", "B", "U", "D", "L", "R"));
    for(String s: b.neighbors) faces.remove(s);
    for(String s: faces) res += s;
    return res;
  }
  
  private void removeNeighbors(Block block, PVector disps, int size){
    float offset = size/2;
    if(size % 2 == 0) offset -= 0.5f;
    //X+ Face (R)
    if(disps.x == offset) block.removeNeighbor("R");
    //X- Face(L)
    if(disps.x == -1*offset) block.removeNeighbor("L");
    //Y+ Face (D)
    if(disps.y == offset) block.removeNeighbor("D");
    //Y- Face (U)
    if(disps.y == -1*offset) block.removeNeighbor("U");
    //Z+ Face (F)
    if(disps.z == offset) block.removeNeighbor("F");
    //Z- Face (B)
    if(disps.z == -1*offset) block.removeNeighbor("B");
  }
  
  public void show(){
    if(!readyToTurn){
      for(String g: displayOrder){ 
        blockGroups.get(g).drawBlocks(this, fillBlock);
      }
    }
    else{
      for(int idx: getDisplayOrderGroups()){
        generateDisplayOrder(groupStages.get(idx));
        for(String g: displayOrder){
          if(groupStages.get(idx).containsKey(g)){
            groupStages.get(idx).get(g).drawBlocks(this, fillBlock);
          }
        }
      }
    }
    //axis.show();
  }
  
  public void transform(char direction, int amount){
    for(Block b: blocks) b.transform(direction, amount);
    axis.transform(direction, amount);
  }
  
  public void updateMoves(){
    if(turnQueue.size() > 0 && currentTurn == null){
      currentTurn = turnQueue.removeFirst();
    }
    if(currentTurn != null){
      if(moveAnimationCounter < currentTurn.turnCount*90){
        moveAnimationCounter += abs(currentTurn.directionAmount);
        if(!readyToTurn){
          setUpBlocksToTurn(Moves.valueOf(currentTurn.faceToTurn), currentTurn.d);
        }
        turnFace();
      }else{
        moveAnimationCounter = 0;
        shuffleBlocks();
      }
    }
  }
  
  public void updateState(char direction, int amount){
    for(Block b: blocks){
      b.transform(direction, amount);
      b.updateQXYZ(direction, amount);
    }
    axis.updateQXYZ(direction, amount);
    generateDisplayOrder(blockGroups);
  }
    
  public void reset(){    
    for(int i = 0; i < originalBlockDisps.length; i++){
      blocks[i] = new Block(center, cubeSize, originalBlockDisps[i].copy(), fillBlock);
      removeNeighbors(blocks[i], originalBlockDisps[i], size);
      
      String facesToShow = getFacesToShow(blocks[i]);
      blockGroups.get(facesToShow).addBlockIdx(i);
    }
    
    axis.reset();
  }
  
  public PVector[] getNumbers(int base){
    if(base < 1) return null;
    ArrayList<PVector> disps = new ArrayList<PVector>();
    int offset = (int)Math.floor(base/2.0f);
    int adjustedBase = base + ((base + 1) % 2);
    for(int i = 0; i < adjustedBase; i++){
      for(int j = 0; j < adjustedBase; j++){
        for(int k = 0; k < adjustedBase; k++){
          disps.add(new PVector(k - offset, j - offset, i - offset));
        }
      }
    }
    
    PVector[] result = new PVector[base*base*base];
    int counter = 0;
    for(int i = 0; i < disps.size(); i++){
      if((disps.get(i).x == 0.0f || disps.get(i).y == 0.0f || disps.get(i).z == 0.0f) && base % 2 == 0){
        continue;
      }
      result[counter] = disps.get(i);
      if(base % 2 == 0){
        PVector translationFactor = disps.get(i).copy();
        //Scale everything down to either 0.5 or -0.5
        translationFactor.x /= -2*abs(translationFactor.x);
        translationFactor.y /= -2*abs(translationFactor.y);
        translationFactor.z /= -2*abs(translationFactor.z);
        //add translationFactor to result
        result[counter].add(translationFactor);
      }
      counter++;
    }
    return result;
  }
  
  public void toggleMovingBlock(int index, boolean state){
    if(index < 0 || index >= blocks.length) return;    
    blocks[index].isMoving = state;
  }
  
  private void setUpBlocksToTurn(Moves faceToTurn, int layer){
    if(layer < 0) layer = 0;
    if(layer >= cubeSize) layer = cubeSize - 1;

    for(int r = 0; r < cubeSize; r++){
      for(int i = 0; i < cubeSize; i++){
        int index = currentTurn.d*currentTurn.cd + r*currentTurn.cr + i*currentTurn.ci;
        toggleMovingBlock(index, true);
        
        blocks[index].setFaceState(Moves.valueOf(currentTurn.oppFace), 0);
        if(cubeSize > 1){
          blocks[index + currentTurn.diff].setFaceState(Moves.valueOf(currentTurn.faceToTurn), 0);
        }
        if(!isLayerOnEdge(currentTurn.d, currentTurn.cubeSize)){
          blocks[index].setFaceState(Moves.valueOf(currentTurn.faceToTurn), 0);
          blocks[index - currentTurn.diff].setFaceState(Moves.valueOf(currentTurn.oppFace), 0);
        }
      }
    }
    generateGroups(faceToTurn, layer);
    readyToTurn = true;
  }
  
  private void turnFace(){
    if(!readyToTurn) return;
    currentTurn.setAxis(axis);
  
    for(int r = 0; r < cubeSize; r++){
      for(int i = 0; i < cubeSize; i++){
        int index = currentTurn.d*currentTurn.cd + r*currentTurn.cr + i*currentTurn.ci;
        blocks[index].updateQAroundAxis(currentTurn.axisOfRotation, currentTurn.directionAmount);
      }
    }
  }
  
  private int[][] rotateIndexes(int[][] initPosArr, boolean isClockwise){
    int[][] arrTranspose = new int[cubeSize][cubeSize];
    int[][] arrResFlipped = new int[cubeSize][cubeSize];
    
    for(int i = 0; i < cubeSize; i++){
      for(int j = 0; j < cubeSize; j++){
        arrTranspose[i][j] = initPosArr[j][i];
      }
    }
    if(isClockwise){
      for(int i = 0; i < cubeSize; i++){
        for(int j = 0; j < cubeSize; j++){
          arrResFlipped[i][j] = arrTranspose[i][cubeSize - j - 1];
        }
      }
    }else{
      for(int i = 0; i < cubeSize; i++){
        for(int j = 0; j < cubeSize; j++){
          arrResFlipped[i][j] = arrTranspose[cubeSize - i - 1][j];
        }
      }
    }
    return arrResFlipped;
  }
  
  private void shuffleBlocks(){
    int[][] initPosArr = new int[cubeSize][cubeSize];
    
    for(int r = 0; r < cubeSize; r++){
      for(int i = 0; i < cubeSize; i++){
        int dIdx = currentTurn.d * currentTurn.cd;
        int rIdx = currentTurn.rInv ? (cubeSize - r - 1)* currentTurn.cr : r* currentTurn.cr;
        int iIdx = currentTurn.iInv ? (cubeSize - i - 1)* currentTurn.ci : i* currentTurn.ci;
        
        initPosArr[r][i] = dIdx + rIdx + iIdx;
      }
    }
    
    int[][] rotatedArr = rotateIndexes(initPosArr, currentTurn.directionAmount > 0);
    if(currentTurn.turnCount == 2) rotatedArr = rotateIndexes(rotatedArr, currentTurn.directionAmount > 0);
    
    Block[][] blockArr = new Block[cubeSize][cubeSize];
    
    for(int i = 0; i < cubeSize; i++){
      for(int j = 0; j < cubeSize; j++){
        blockArr[i][j] = blocks[rotatedArr[i][j]];
        toggleMovingBlock(rotatedArr[i][j], false);
      }
    }
    
    for(int i = 0; i < cubeSize; i++){
      for(int j = 0; j < cubeSize; j++){
        int index = initPosArr[i][j];
        blocks[index] = blockArr[i][j];
        blocks[index].applyTurnRotation(currentTurn);
        
        blocks[index].setFaceState(Moves.valueOf(currentTurn.oppFace), -1);
        if(cubeSize > 1){
          blocks[index + currentTurn.diff].setFaceState(Moves.valueOf(currentTurn.faceToTurn), -1);
        }
        if(!isLayerOnEdge(currentTurn.d, currentTurn.cubeSize)){
          blocks[index].setFaceState(Moves.valueOf(currentTurn.faceToTurn), -1);
          blocks[index - currentTurn.diff].setFaceState(Moves.valueOf(currentTurn.oppFace), -1);
        }
      }
    }
    
    currentTurn = null;
    readyToTurn = false;
  }
  
  public void addMove(Moves m, int currDepth, boolean isTurnClockwise, int count){
    turnQueue.add(new Turn(cubeSize, currDepth, m, isTurnClockwise, count));
  }
  
  public void generateDisplayOrder(HashMap<String, PieceGroup> groupMap){
    HashMap<String, PieceGroup> groupMapCopy = new HashMap<String, PieceGroup>();
    for(PieceGroup g: groupMap.values()){
      g.setPosition(this);
      groupMapCopy.put(g.getFacesAsString(), g);
    }
    ArrayList<String> res = new ArrayList<String>();
    
    while(groupMapCopy.size() > 0){
      PieceGroup currGroup = new PieceGroup(PieceType.Internal, null);
      for(String s: groupMapCopy.keySet()){
        if(isVectorFurther(groupMapCopy.get(s).position, currGroup.position, marginOfErrors[cubeSize - 1])){
          currGroup = groupMapCopy.get(s);
        }
      } 
      res.add(currGroup.getFacesAsString());
      groupMapCopy.remove(currGroup.getFacesAsString());
    }
    
    displayOrder = res;
  }
  
  private ArrayList<Integer> getDisplayOrderGroups(){
    ArrayList<Integer> groupOrder = new ArrayList<Integer>();
    ArrayList<ArrayList<Integer>> groupsToCompare = currentTurn.generateGroupList(this);
    HashMap<Integer, PVector> groupLists = new HashMap<Integer, PVector>();
    
    for(int i = 0; i < groupsToCompare.size(); i++){
      PVector closestP = new PVector(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE);
      
      for(int p = 0; p < groupsToCompare.get(i).size(); p += cubeSize % 2){
        if(cubeSize % 2 == 0){
          PVector currP = new PVector(0, 0, 0);
          for(int j = 0; j < 4; j++, p++){
            currP.add(blocks[groupsToCompare.get(i).get(p)].distToCenter.copy());
          }
          if(isVectorFurther(closestP, currP, marginOfErrors[cubeSize - 1])){
            closestP = currP;
          }
        }else{
          if(isVectorFurther(closestP, blocks[groupsToCompare.get(i).get(p)].distToCenter.copy(), marginOfErrors[cubeSize - 1])){
            closestP = blocks[groupsToCompare.get(i).get(p)].distToCenter.copy();
          }
        }
      }
      groupLists.put(i, closestP);
    }
        
    while(groupLists.size() > 0){
      PVector currFurthestPoint = new PVector(0, 0, Integer.MAX_VALUE);
      int index = 0;
      for(int i: groupLists.keySet()){
        PVector currP = groupLists.get(i);
        if(isVectorFurther(currP, currFurthestPoint, marginOfErrors[cubeSize - 1])){
          currFurthestPoint = currP;
          index = i;
        }
      }
      groupOrder.add(index);
      groupLists.remove(index);
    }
    return groupOrder;
  }
  
  private void generateGroups(Moves face, int layer){
    /*
    Group 0: Groups that match the face
    Group 1: Groups that don't match the face(s)
    Group 2: Groups that match the opposite face (slice turns only)
    */
    groupStages.clear();
    
    HashMap<String, PieceGroup> groupMatchesFace = new HashMap<String, PieceGroup>();
    HashMap<String, PieceGroup> groupDoesntMatchBothFaces = new HashMap<String, PieceGroup>();
    HashMap<String, PieceGroup> groupMatchesOppositeFace = new HashMap<String, PieceGroup>();
    
    for(String s: blockGroups.keySet()){
      PieceGroup currGroup = (PieceGroup) blockGroups.get(s).clone();
      if(s.contains(face.name())){ //matches face
        groupMatchesFace.put(s, currGroup);
      }
      else if(!isLayerOnEdge(layer, cubeSize) && s.contains(Moves.getOppositeFace(face.name()))){ //matches opposite face
        groupMatchesOppositeFace.put(s, currGroup);
      }
      else{ //doesn't match either face
        if(layer > 0 && layer < cubeSize - 1){
          groupMatchesFace.put(s, (PieceGroup) currGroup.clone());
          groupMatchesFace.get(s).filterNonMovingBlocks(this, '<', currentTurn);
          if(groupMatchesFace.get(s).indexList.size() == 0) groupMatchesFace.remove(s);
        }
        
        groupDoesntMatchBothFaces.put(s, (PieceGroup) currGroup.clone());
        groupDoesntMatchBothFaces.get(s).filterNonMovingBlocks(this, '=', currentTurn);
        if(groupDoesntMatchBothFaces.get(s).indexList.size() == 0) groupDoesntMatchBothFaces.remove(s);

        if(!isLayerOnEdge(layer, cubeSize)){
          groupMatchesOppositeFace.put(s, (PieceGroup) currGroup.clone());
          groupMatchesOppositeFace.get(s).filterNonMovingBlocks(this, '>', currentTurn);
          if(groupMatchesOppositeFace.get(s).indexList.size() == 0) groupMatchesOppositeFace.remove(s);
        }
      }
    }
    
    groupStages.addAll(Arrays.asList(groupMatchesFace, groupDoesntMatchBothFaces));
    if(layer > 0) groupStages.add(groupMatchesOppositeFace);
  }
}
enum Moves{
  U, 
  D, 
  R, 
  L, 
  F, 
  B;
  
  public static String getOppositeFace(String face){
    switch(face.charAt(0)){
      case 'F':
        return "B";
      case 'B':
        return "F";
      case 'U':
        return "D";
      case 'D':
        return "U";
      case 'L':
        return "R";
      case 'R':
        return "L";
    }
    println("Invalid face specified");
    return "";
  }
  
  public static String getAllFaces(){
    return "UDRLFB";
  }
}
class PieceGroup implements Cloneable{
  ArrayList<Integer> indexList = new ArrayList<Integer>();
  PieceType groupType;
  String[] facesToShow;
  PVector position = new PVector(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);
  
  public PieceGroup(PieceType type, String[] faces){
    groupType = type;
    facesToShow = faces;
  }
  
  public void addBlockIdx(int b){
    indexList.add(b);
  }
    
  public String getFacesAsString(){
    String s = "";
    for(String c: facesToShow) s += c;
    return s;
  }
  
  public PVector setPosition(Cube c){
    PVector sumPos = new PVector(0, 0, 0);
    for(int idx: indexList) sumPos.add(c.blocks[idx].distToCenter.copy());
    position = sumPos.div(indexList.size()).copy();
    return position;
  }
  
  public PVector getClosestToCenter(Cube c){
    PVector resPos = new PVector(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);
    for(int idx: indexList){
      if(get2DLength(resPos) > get2DLength(c.blocks[idx].distToCenter.copy())){
        resPos = c.blocks[idx].distToCenter.copy();
      }
    }
    return resPos;
  }
  
  public void flipAll(Cube c, boolean state){
    for(int idx: indexList) c.blocks[idx].fillBlock = state;
  }
  
  public void drawBlocks(Cube c, boolean fillBlock){    
    //block index, faces to show
    HashMap<Integer, ArrayList<String>> facesToShowList = new HashMap<Integer, ArrayList<String>>();
    //number of faces to show, block index
    HashMap<Integer, ArrayList<Integer>> indexGroups = new HashMap<Integer, ArrayList<Integer>>();
    //number of faces to show, closest point
    HashMap<Integer, PVector> closestPoints = new HashMap<Integer, PVector>();
    
    for(int idx: indexList){
      ArrayList<String> facesToShow = fillBlock ? c.blocks[idx].findFacesToShow() : c.blocks[idx].findFacesToShowNoFill();
      int numOfFaces = facesToShow.size();
      
      if(!indexGroups.containsKey(numOfFaces)) indexGroups.put(numOfFaces, new ArrayList<Integer>());
      indexGroups.get(numOfFaces).add(idx);
      
      if(!closestPoints.containsKey(numOfFaces)){
        closestPoints.put(numOfFaces, new PVector(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE));
      }
      if(isVectorFurther(closestPoints.get(numOfFaces), c.blocks[idx].distToCenter.copy(), marginOfErrors[c.cubeSize - 1])){
        closestPoints.put(numOfFaces, c.blocks[idx].distToCenter.copy());
      }
      facesToShowList.put(idx, facesToShow);
    }
    
    ArrayList<Integer> orderToDraw = new ArrayList<Integer>();
    while(closestPoints.size() > 0){
      PVector closestP = new PVector(0, 0, Integer.MAX_VALUE);
      int index = 0;
      for(int i: closestPoints.keySet()){
        if(isVectorFurther(closestPoints.get(i), closestP, marginOfErrors[c.cubeSize - 1])){
          closestP = closestPoints.get(i);
          index = i;
        }
      }
      orderToDraw.add(index);
      closestPoints.remove(index);
    }

    //goes through faces to show groups
    for(int numOfFacesToDraw: orderToDraw){
      //goes through number of faces to show
      for(int faceIdx = 0; faceIdx < numOfFacesToDraw; faceIdx++){
        //goes through all block indexes
        for(int blockIndex : indexGroups.get(numOfFacesToDraw)){
          String f = facesToShowList.get(blockIndex).get(faceIdx);
          c.blocks[blockIndex].showFace(Moves.valueOf(f));
          c.blocks[blockIndex].showColor(Moves.valueOf(f));
        }
      }
    }
  }
  
  public void filterNonMovingBlocks(Cube c, char state, Turn turn){
    ArrayList<Integer> movingIndexList = new ArrayList<Integer>();
    for(int i: indexList) if(c.blocks[i].isMoving == true) movingIndexList.add(i);
    if(movingIndexList.size() == 0) return;
    
    ArrayList<Integer> resultIndexList = new ArrayList<Integer>();
    switch(state){
      case '<':
        Collections.reverse(movingIndexList);
        for(int idx: movingIndexList){
          int currIndex = (turn.dInv) ? idx + turn.cd : idx - turn.cd;
          int diff = (turn.dInv) ? turn.cd : -1*turn.cd;
          while(indexList.contains(currIndex)){
            resultIndexList.add(currIndex);
            currIndex += diff;
          }
        }
        Collections.reverse(resultIndexList);
        break;
      case '>':
        for(int idx: movingIndexList){
          int currIndex = (turn.dInv) ? idx - turn.cd : idx + turn.cd;
          int diff = (turn.dInv) ? -1*turn.cd : turn.cd;
          while(indexList.contains(currIndex)){
            resultIndexList.add(currIndex);
            currIndex += diff;
          }
        }
        break;
      case '=':
        resultIndexList = movingIndexList;
    }
    indexList = resultIndexList;
  }
  
  public Object clone(){  
    try{  
        return super.clone();  
    }catch(Exception e){ 
        return null; 
    }
  }
}
enum PieceType{
  Corner,
  Edge,
  Center,
  Internal;
  
  public static PieceType getType(String facesToShow){
    switch(facesToShow.length()){
      case 3:
        return Corner;
      case 2:
        return Edge;
      case 1:
        return Center;
      default:
        return Internal;
    }
  }
}
class Turn{
  int cr = 0;    //row coefficient
  int ci = 0;    //index coefficient
  int cd = 0;    //depth coefficient
  int d = 0;     //depth value
  int diff = 0;  //difference between two layers
  int cubeSize = 0;
  String faceToTurn;
  String oppFace;
  PVector axisOfRotation = new PVector(0, 0, 0);
  boolean iInv = false;
  boolean rInv = false;
  boolean dInv = false;
  int directionAmount = 0;
  int turnCount = 0;
  
  /*
  Faces to target: (d is depth layer), Start by directly facing the center of the face to rotate
  Note: d can be anywhere from 0 to n - 1,
  Note: i and r starts at 0 (i0 and r0), goes to n - 1 (i1 and r1)
  Note: var' = n - var - 1
  
  B: (Blue)
  [d*n*n + r0*n + i0', d*n*n + r0*n + i1']
  ...
  [d*n*n + r1*n + i0', d*n*n + r1*n + i1']
  
  Ex: (d = 0)
  [04, 03, 02, 01, 00]
  [09, 08, 07, 06, 05]
  [14, 13, 12, 11, 10]
  [19, 18, 17, 16, 15]
  [24, 23, 22, 21, 20]
  
  F: (Green)
  [d'*n*n + r0*n + i0, d'*n*n + r0*n + i1]
  ...
  [d'*n*n + r1*n + i0, d'*n*n + r1*n + i1]
  
  Ex: (d = 0)
  [100, 101, 102, 103, 104]
  [105, 106, 107, 108, 109]
  [110, 111, 112, 113, 114]
  [115, 116, 117, 118, 119]
  [120, 121, 122, 123, 124]
  
  R: (Red)
  [d' + r0*n + i0'*n*n, d' + r0*n + i1'*n*n]
  ...
  [d' + r1*n + i1'*n*n, d' + r1*n + i1'*n*n]
  
  Ex: (d = 0)
  [104, 79, 54, 29, 04]
  [109, 84, 59, 34, 09]
  [114, 89, 64, 39, 14]
  [119, 94, 69, 44, 19]
  [124, 99, 74, 49, 24]
  
  L: (Orange)
  [d + r0*n + i0*n*n, d + r0*n + i1*n*n]
  ...
  [d + r1*n + i0*n*n, d + r1*n + i1*n*n]
  
  Ex: (d = 0)
  [00, 25, 50, 75, 100]
  [05, 30, 55, 80, 105]
  [10, 35, 60, 85, 110]
  [15, 40, 65, 90, 115]
  [20, 45, 70, 95, 120]
  
  U: (White)
  [d*n + r0*n*n + i0, d + r0*n*n + i1]
  ...
  [d*n + r1*n*n + i0, d + r1*n*n + i1]
  
  Ex: (d = 0)
  [000, 001, 002, 003, 004]
  [025, 026, 027, 028, 029]
  [050, 051, 052, 053, 054]
  [075, 076, 077, 078, 079]
  [100, 101, 102, 103, 104]
  
  D: (Yellow)
  [d'*n + r0'*n*n + i0, d'*n + r0'*n*n + i1]
  ...
  [d'*n + r1'*n*n + i0, d'*n + r1'*n*n + i1]
  
  Ex: (d = 0)
  [120, 121 ,122, 123, 124]
  [095, 096, 097, 098, 099]
  [070, 071, 072, 073, 074]
  [045, 046, 047, 048, 049]
  [020, 021, 022, 023, 024]
  */
  
  public Turn(int size, int layer, Moves move, boolean isTurnClockwise, int turnCounter){
    cubeSize = size;
    directionAmount = isTurnClockwise ? 2 : -2;
    turnCount = turnCounter;
    switch(move.name().charAt(0)){
      case 'B':
        cd = size*size;
        cr = size;
        ci = 1;
        d = layer;
        diff = size*size;
        iInv = true;
        break;
      case 'F':
        cd = size*size;
        cr = size;
        ci = 1;
        d = (size - layer - 1);
        diff = -1*size*size;
        dInv = true;
        break;
      case 'U':
        cd = size;
        cr = size*size;
        ci = 1;
        d = layer;
        diff = size;
        break;
      case 'D':
        cd = size;
        cr = size*size;
        ci = 1;
        d = (size - layer - 1);
        diff = -1*size;
        rInv = true;
        dInv = true;
        break;
      case 'L':
        cd = 1;
        cr = size;
        ci = size*size;
        d = layer;
        diff = 1;
        break;
      case 'R':
        cd = 1;
        cr = size;
        ci = size*size;
        d = (size - layer - 1);
        diff = -1;
        iInv = true;
        dInv = true;
        break;
    }
    faceToTurn = move.name();
    oppFace = Moves.getOppositeFace(move.name());
  }
    
  public void setAxis(Axis axis){
    switch(faceToTurn.charAt(0)){
      case 'B':
        axisOfRotation = axis.getAxisOfRotation('z', true);
        break;
      case 'F':
        axisOfRotation = axis.getAxisOfRotation('z', false);
        break;
      case 'U':
        axisOfRotation = axis.getAxisOfRotation('y', true);
        break;
      case 'D':
        axisOfRotation = axis.getAxisOfRotation('y', false);
        break;
      case 'L':
        axisOfRotation = axis.getAxisOfRotation('x', true);
        break;
      case 'R':
        axisOfRotation = axis.getAxisOfRotation('x', false);
        break;
    }
  }
  
  public ArrayList<ArrayList<Integer>> generateGroupList(Cube c){
    ArrayList<ArrayList<Integer>> groups = new ArrayList<ArrayList<Integer>>();
    groups.addAll(Arrays.asList(new ArrayList<Integer>(), new ArrayList<Integer>()));
    if(!isLayerOnEdge(d, cubeSize)) groups.add(new ArrayList<Integer>());
    ArrayList<Integer> currIndexes = new ArrayList<Integer>();
    //adds the center(s) of the cube
    if(cubeSize % 2 == 1){
      currIndexes.add((cubeSize/2)*cr + (cubeSize/2)*ci);
    }else{
      currIndexes.add((cubeSize/2 - 1)*cr + (cubeSize/2 - 1)*ci);
      currIndexes.add((cubeSize/2 - 1)*cr + (cubeSize/2)*ci);
      currIndexes.add((cubeSize/2)*cr + (cubeSize/2 - 1)*ci);
      currIndexes.add((cubeSize/2)*cr + (cubeSize/2)*ci);
    }

    int currGroup = c.blocks[currIndexes.get(0)].isMoving || isOnZerothLayer(d, cubeSize, dInv) ? 1 : (dInv) ? 2 : 0;
    currGroup = (d == 0) ? 0 : (d == cubeSize - 1) ? 1 : (dInv) ? 2: 0;
    boolean prevState = c.blocks[currIndexes.get(0)].isMoving;
    int groupDiff = (currGroup > 0) ? -1 : 1;
    for(int i = 0; i < cubeSize; i++){
      for(int idx = 0; idx < currIndexes.size(); idx++){
        if(c.blocks[currIndexes.get(idx)].isMoving != prevState){
          currGroup += groupDiff;
          prevState = c.blocks[currIndexes.get(idx)].isMoving;
        }
        groups.get(currGroup).add(currIndexes.get(idx));
        currIndexes.set(idx, currIndexes.get(idx) + cd);
      }
    }
    return groups;
  }
  
  public String getInformation(){
    String s = "";
    int layer = dInv ? cubeSize - d : d + 1;
    s += (char) (0x2080 + layer); 
    s += faceToTurn;
    if(turnCount == 2) s += "2";
    if(directionAmount < 0) s += "'";
    return s;
  }
}
public PVector[] applyPerspectiveProjection(PVector[] initialDisps, PVector distToCenter){
  PVector[] resultDisps = new PVector[initialDisps.length];
  for(int i = 0; i < initialDisps.length; i++){
    PVector totalDistanceVector = initialDisps[i].copy();
    totalDistanceVector.add(distToCenter.copy().mult(2));
    float z = 1 / (cameraDistanceFactors[size - 1] - totalDistanceVector.z);

    resultDisps[i] = totalDistanceVector.mult(z).mult(blockLengths[size - 1]*scalingFactors[size - 1]);
    resultDisps[i].x += center.x;
    resultDisps[i].y += center.y;
  } 
  return resultDisps;
}

public PVector applyPerspectiveProjection(PVector initialDisp, PVector distToCenter){
  PVector resultDisp = new PVector(0, 0, 0);
  PVector totalDistanceVector = initialDisp.copy();
  totalDistanceVector.add(distToCenter.copy().mult(2));
  float z = 1 / (cameraDistanceFactors[size - 1] - totalDistanceVector.z);

  resultDisp = totalDistanceVector.mult(z).mult(blockLengths[size - 1]*scalingFactors[size - 1]);
  resultDisp.x += center.x;
  resultDisp.y += center.y;

  return resultDisp;
}

public static PVector rotateQ(float qRe, PVector qIm, PVector vIm){
  /*
  Source: http://people.csail.mit.edu/bkph/articles/Quaternions.pdf
  V' = V + 2w(Q x V) + (2Q x (Q x V))
  V' = V + w(2(Q x V)) + (Q x (2(Q x V))
  T = 2(Q x V)
  V' = V + w*(T) + (Q x T)
  
  w = qReal
  Q = qImaginary (axis of rotation)
  V = vImaginary (point to rotate)
  */
  PVector result = new PVector(0, 0, 0);
  PVector T = (crossProduct(qIm, vIm)).mult(2);
  result = vIm.copy().add(T.copy().mult(qRe)).add(crossProduct(qIm, T));
  
  return result;
}

public static PVector crossProduct(PVector v1, PVector v2){
  PVector result = new PVector(0, 0, 0);
  result.x = v1.y * v2.z - v1.z * v2.y;
  result.y = v1.z * v2.x - v1.x * v2.z;
  result.z = v1.x * v2.y - v1.y * v2.x;
  
  return result;
}

public PVector rotateAroundAxis(float rotationAmount, char rotationDirection, PVector pointToRotate){
  PVector returnVal = pointToRotate.copy();
  float rotationAmtHalf = rotationAmount * 0.5f;
  float rotationCoefficient = getCos(rotationAmtHalf);

  switch(rotationDirection){
    case 'x':
      PVector xAxis = new PVector(1, 0, 0).mult(getSin(rotationAmtHalf));
      returnVal = rotateQ(rotationCoefficient, xAxis, returnVal);
      break;
    case 'y':
      PVector yAxis = new PVector(0, 1, 0).mult(getSin(rotationAmtHalf));
      returnVal = rotateQ(rotationCoefficient, yAxis, returnVal);
      break;
    case 'z':
      PVector zAxis = new PVector(0, 0, 1).mult(getSin(rotationAmtHalf));
      returnVal = rotateQ(rotationCoefficient, zAxis, returnVal);
      break;
  }
  return returnVal;
}

public PVector rotateAroundCustomAxis(float rotationAmount, PVector axisOfRotation, PVector pointToRotate){
  PVector returnVal = pointToRotate.copy();
  float rotationAmtHalf = rotationAmount * 0.5f;
  float rotationCoefficient = getCos(rotationAmtHalf);
 
  PVector customAxis = axisOfRotation.copy().mult(getSin(rotationAmtHalf));
  returnVal = rotateQ(rotationCoefficient, customAxis, returnVal);
 
  return returnVal;
}

public static float get2DLength(PVector p){
  return p.x*p.x + p.y*p.y;
}

public static boolean isVectorFurther(PVector p1, PVector p2, float marginOfError){
  if(abs(p1.z - p2.z) < marginOfError) return get2DLength(p1) > get2DLength(p2);
  else return p1.z < p2.z;
}

public void setDepth(int depth){
  if(depth < 1 || depth > (cube.cubeSize / 2) + (cube.cubeSize % 2)) return;
  currentDepth = depth - 1;
}

public static boolean isLayerOnEdge(int layer, int size){
  return (layer == 0) || (layer == size - 1);
}

public static boolean isOnZerothLayer(int layer, int size, boolean dInv){
  return (layer == 0 && !dInv) || (layer == size - 1 && dInv);
}

public float getCos(float angle){
  return cosTable[(int)(angle*2 + 360) % 360];
}

public float getSin(float angle){
  return sinTable[(int)(angle*2 + 360) % 360];
}


  public void settings() { size(800, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Rubiks_Cube" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
